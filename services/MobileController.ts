
import { Scene, GameObjects, Input } from 'phaser';
import { MobileBridge } from './MobileBridge';

/**
 * MobileController (Phaser)
 * Replaces the flaky React DOM joystick with a rock-solid Phaser Touch Zone.
 */
export class MobileController {
  private scene: Scene;
  private base: GameObjects.Image;
  private thumb: GameObjects.Image;
  private touchZone: GameObjects.Zone;
  private touchId: number | null = null;
  private origin = { x: 0, y: 0 };
  private radius: number = 60;

  constructor(scene: Scene) {
    this.scene = scene;
    this.create();
  }

  create() {
    // 1. Enable Multi-Touch
    // FIX: Do not access .pointers.length directly as it may not exist on InputPlugin in all Phaser versions.
    // Just add pointers blindly; Phaser handles the limit safely.
    if (this.scene.input && this.scene.input.addPointer) {
      this.scene.input.addPointer(2); 
    }

    // 2. Create Visuals (Hidden by default)
    // Ensure textures exist (generated by TextureGenerator)
    const baseKey = this.scene.textures.exists('ui-joystick-base') ? 'ui-joystick-base' : '';
    const stickKey = this.scene.textures.exists('ui-joystick-stick') ? 'ui-joystick-stick' : '';

    if (!baseKey) {
        // Fallback graphics if texture gen failed/delayed
        const g = this.scene.make.graphics({x:0, y:0, add:false});
        g.lineStyle(2, 0x00ffff); g.strokeCircle(64,64,50);
        g.generateTexture('ui-joystick-base', 128, 128);
        g.clear();
        g.fillStyle(0x00ffff, 0.5); g.fillCircle(32,32,20);
        g.generateTexture('ui-joystick-stick', 64, 64);
    }

    this.base = this.scene.add.image(0, 0, 'ui-joystick-base').setDepth(9000).setVisible(false).setScrollFactor(0);
    this.thumb = this.scene.add.image(0, 0, 'ui-joystick-stick').setDepth(9001).setVisible(false).setScrollFactor(0);

    // 3. Create Hit Zone (Left Half of Screen)
    const width = this.scene.scale.width;
    const height = this.scene.scale.height;
    
    this.touchZone = this.scene.add.zone(width / 4, height / 2, width / 2, height)
      .setRectangleDropZone(width / 2, height)
      .setScrollFactor(0)
      .setInteractive()
      .setDepth(8999);

    // 4. Input Events
    this.touchZone.on('pointerdown', this.handleDown, this);
    this.touchZone.on('pointermove', this.handleMove, this);
    this.touchZone.on('pointerup', this.handleUp, this);
    this.touchZone.on('pointerout', this.handleUp, this);
  }

  private handleDown(pointer: Input.Pointer) {
    if (this.touchId !== null) return; // Already tracking a finger

    this.touchId = pointer.id;
    this.origin = { x: pointer.x, y: pointer.y };
    
    this.base.setPosition(pointer.x, pointer.y).setVisible(true);
    this.thumb.setPosition(pointer.x, pointer.y).setVisible(true);
    
    MobileBridge.moveDir = { x: 0, y: 0 };
  }

  private handleMove(pointer: Input.Pointer) {
    if (pointer.id !== this.touchId) return;

    const dx = pointer.x - this.origin.x;
    const dy = pointer.y - this.origin.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    
    let moveX = dx;
    let moveY = dy;

    // Clamp visual
    if (dist > this.radius) {
        const ratio = this.radius / dist;
        moveX = dx * ratio;
        moveY = dy * ratio;
    }

    this.thumb.setPosition(this.origin.x + moveX, this.origin.y + moveY);

    // Normalize output
    MobileBridge.moveDir = {
        x: moveX / this.radius,
        y: moveY / this.radius
    };
  }

  private handleUp(pointer: Input.Pointer) {
    if (pointer.id !== this.touchId) return;

    this.touchId = null;
    this.base.setVisible(false);
    this.thumb.setVisible(false);
    MobileBridge.moveDir = { x: 0, y: 0 };
  }

  public destroy() {
      if (this.touchZone) this.touchZone.destroy();
      if (this.base) this.base.destroy();
      if (this.thumb) this.thumb.destroy();
  }
}
